python module _SHTOOLS
!------------------------------------------------------------------------------
!
!   Python signature file for the SHTOOLS Fortran 95 routines. The
!   definitions of how the fortran functions are actually called are found in
!   the wrapper file PythonWrapper.f95.
!
!   Note: The context of this file is case sensitive.
!
!------------------------------------------------------------------------------
    interface

        subroutine PlmBar(exitstatus,p,lmax,z,csphase,cnorm,p_d0)
            threadsafe
            fortranname pyplmbar
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmBar

        subroutine PlmBar_d1(exitstatus,p,dp1,lmax,z,csphase,cnorm,p_d0,dp1_d0)
            threadsafe
            fortranname pyplmbar_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmBar_d1

        subroutine PlBar(exitstatus,p,lmax,z,p_d0)
            threadsafe
            fortranname pyplbar
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
        end subroutine PlBar

        subroutine PlBar_d1(exitstatus,p,dp1,lmax,z,p_d0,dp1_d0)
            threadsafe
            fortranname pyplbar_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out):: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = lmax+1
        end subroutine PlBar_d1

        subroutine PlmON(exitstatus,p,lmax,z,csphase,cnorm,p_d0)
            threadsafe
            fortranname pyplmon
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmON

        subroutine PlmON_d1(exitstatus,p,dp1,lmax,z,csphase,cnorm,p_d0,dp1_d0)
            threadsafe
            fortranname pyplmon_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmON_d1

        subroutine PlON(exitstatus,p,lmax,z,p_d0)
            threadsafe
            fortranname pyplon
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
        end subroutine PlON

        subroutine PlON_d1(exitstatus,p,dp1,lmax,z,p_d0,dp1_d0)
            threadsafe
            fortranname pyplon_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = lmax+1
        end subroutine PlON_d1

        subroutine PlmSchmidt(exitstatus,p,lmax,z,csphase,cnorm,p_d0)
            threadsafe
            fortranname pyplmschmidt
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmSchmidt

        subroutine PlmSchmidt_d1(exitstatus,p,dp1,lmax,z,csphase,cnorm,p_d0,dp1_d0)
            threadsafe
            fortranname pyplmschmidt_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out):: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: cnorm = 0
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmSchmidt_d1

        subroutine PlSchmidt(exitstatus,p,lmax,z,p_d0)
            threadsafe
            fortranname pyplschmidt
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
        end subroutine PlSchmidt

        subroutine PlSchmidt_d1(exitstatus,p,dp1,lmax,z,p_d0,dp1_d0)
            threadsafe
            fortranname pyplschmidt_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = lmax+1
        end subroutine PlSchmidt_d1

        subroutine PLegendreA(exitstatus,p,lmax,z,csphase,p_d0)
            threadsafe
            fortranname pyplegendrea
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PLegendreA

        subroutine PLegendre(exitstatus,p,lmax,z,p_d0)
            threadsafe
            fortranname pyplegendre
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
        end subroutine PLegendre

        subroutine PLegendreA_d1(exitstatus,p,dp1,lmax,z,csphase,p_d0,dp1_d0)
            threadsafe
            fortranname pyplegendrea_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PLegendreA_d1

        subroutine PLegendre_d1(exitstatus,p,dp1,lmax,z,p_d0,dp1_d0)
            threadsafe
            fortranname pyplegendre_d1
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(p_d0),intent(out) :: p
            real(dp),dimension(dp1_d0),intent(out) :: dp1
            integer(int32),intent(in) :: lmax
            real(dp),intent(in) :: z
            integer(int32),intent(hide),depend(lmax),check(lmax>=0) :: p_d0 = lmax+1
            integer(int32),intent(hide),depend(lmax) :: dp1_d0 = lmax+1
        end subroutine PLegendre_d1

        subroutine SHExpandDH(exitstatus,grid,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1)
            threadsafe
            fortranname pyshexpanddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(grid_d0,grid_d1),intent(in) :: grid
            integer(int32),intent(hide),depend(grid_d0) :: n = grid_d0
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),intent(hide) :: lmax
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: sampling = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(n) :: lmax_calc = n/2-1
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d2 = lmax_calc+1
            integer(int32),optional,intent(in),depend(grid),intent(hide) :: grid_d0 = shape(grid,0)
            integer(int32),optional,intent(in),depend(grid),intent(hide) :: grid_d1 = shape(grid,1)
        end subroutine SHExpandDH

        subroutine MakeGridDH(exitstatus,griddh,n,cilm,lmax,norm,sampling,csphase,lmax_calc,extend,cilm_d0,cilm_d1,cilm_d2,griddh_d0,griddh_d1)
            threadsafe
            fortranname pymakegriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(griddh_d0,griddh_d1),intent(out) :: griddh
            integer(int32),intent(hide) :: n
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: sampling = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide) :: griddh_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(sampling,lmax,extend),intent(hide) :: griddh_d1 = sampling*2*(lmax+1)+extend
        end subroutine MakeGridDH

        subroutine SHExpandDHC(exitstatus,grid,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1)
            threadsafe
            fortranname pyshexpanddhc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            complex(dp),dimension(grid_d0,grid_d1),intent(in) :: grid
            integer(int32),intent(hide),depend(grid_d0) :: n = grid_d0
            complex(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),intent(hide) :: lmax
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: sampling = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(n) :: lmax_calc = n/2-1
            integer(int32),optional,intent(in) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d2 = lmax_calc+1
            integer(int32),optional,intent(in),depend(grid),intent(hide) :: grid_d0 = shape(grid,0)
            integer(int32),optional,intent(in),depend(grid),intent(hide) :: grid_d1 = shape(grid,1)
        end subroutine SHExpandDHC

        subroutine MakeGridDHC(exitstatus,griddh,n,cilm,lmax,norm,sampling,csphase,lmax_calc,extend,cilm_d0,cilm_d1,cilm_d2,griddh_d0,griddh_d1)
            threadsafe
            fortranname pymakegriddhc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            complex(dp),dimension(griddh_d0,griddh_d1),intent(out) :: griddh
            integer(int32),intent(hide) :: n
            complex(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: sampling = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide) :: griddh_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(sampling,lmax,extend),intent(hide) :: griddh_d1 = sampling*2*(lmax+1)+extend
        end subroutine MakeGridDHC

        subroutine SHGLQ(exitstatus,lmax,zero,w,zero_d0,w_d0)
            threadsafe
            fortranname pyshglq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            integer(int32),intent(in) :: lmax
            real(dp),dimension(zero_d0),intent(out):: zero
            real(dp),dimension(w_d0),intent(out) :: w
            integer(int32),intent(in),depend(lmax),intent(hide),check(lmax>=0) :: zero_d0 = lmax+1
            integer(int32),intent(in),depend(lmax),intent(hide) :: w_d0 = lmax+1
        end subroutine SHGLQ

        subroutine SHExpandGLQ(exitstatus,cilm,lmax,gridglq,w,zero,norm,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,gridglq_d0,gridglq_d1,zero_d0,w_d0)
            threadsafe
            fortranname pyshexpandglq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),intent(hide),depend(gridglq_d0) :: lmax = gridglq_d0-1
            real(dp),dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            real(dp),dimension(w_d0),intent(in) :: w
            real(dp),dimension(zero_d0),intent(in) :: zero
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d2 = lmax_calc+1
            integer(int32),optional,intent(in),depend(gridglq),intent(hide) :: gridglq_d0 = shape(gridglq,0)
            integer(int32),optional,intent(in),depend(gridglq),intent(hide) :: gridglq_d1 = shape(gridglq,1)
            integer(int32),optional,intent(in),depend(zero),intent(hide) :: zero_d0 = len(zero)
            integer(int32),optional,intent(in),depend(w),intent(hide) :: w_d0 = len(w)
        end subroutine SHExpandGLQ

        subroutine MakeGridGLQ(exitstatus,gridglq,cilm,lmax,zero,norm,csphase,lmax_calc,extend,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0)
            threadsafe
            fortranname pymakegridglq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(gridglq_d0,gridglq_d1),intent(out) :: gridglq
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),dimension(zero_d0),intent(in) :: zero
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: gridglq_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide) :: gridglq_d1 = 2*lmax+1+extend
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(zero),intent(hide) :: zero_d0 = len(zero)
        end subroutine MakeGridGLQ

        subroutine SHExpandGLQC(exitstatus,cilm,lmax,gridglq,w,zero,norm,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,gridglq_d0,gridglq_d1,zero_d0,w_d0)
            threadsafe
            fortranname pyshexpandglqc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            complex(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            complex(dp),dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            real(dp),dimension(w_d0),intent(in) :: w
            real(dp),dimension(zero_d0),intent(in) :: zero
            integer(int32),intent(hide),depend(gridglq_d0) :: lmax = gridglq_d0-1
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),depend(lmax_calc),intent(hide) :: cilm_d2 = lmax_calc+1
            integer(int32),optional,intent(in),depend(gridglq),intent(hide) :: gridglq_d0 = shape(gridglq,0)
            integer(int32),optional,intent(in),depend(gridglq),intent(hide) :: gridglq_d1 = shape(gridglq,1)
            integer(int32),optional,intent(in),depend(zero),intent(hide) :: zero_d0 = len(zero)
            integer(int32),optional,intent(in),depend(w),intent(hide) :: w_d0 = len(w)
        end subroutine SHExpandGLQC

        subroutine MakeGridGLQC(exitstatus,gridglq,cilm,lmax,zero,norm,csphase,lmax_calc,extend,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0)
            threadsafe
            fortranname pymakegridglqc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            complex(dp),dimension(gridglq_d0,gridglq_d1),intent(out) :: gridglq
            complex(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),dimension(zero_d0),intent(in) :: zero
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: gridglq_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide) :: gridglq_d1 = 2*lmax+1+extend
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(zero),intent(hide) :: zero_d0 = len(zero)
        end subroutine MakeGridGLQC

        subroutine GLQGridCoord(exitstatus,latglq,longlq,lmax,nlat,nlong,extend,latglq_d0,longlq_d0)
            threadsafe
            fortranname pyglqgridcoord
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(latglq_d0),intent(out) :: latglq
            real(dp),dimension(longlq_d0),intent(out) :: longlq
            integer(int32),intent(in) :: lmax
            integer(int32),intent(hide) :: nlat
            integer(int32),intent(hide) :: nlong
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: latglq_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide) :: longlq_d0 = 2*lmax+1+extend
        end subroutine GLQGridCoord

        subroutine SHExpandLSQ(exitstatus,cilm,d,lat,lon,nmax,lmax,norm,chi2,csphase,cilm_d0,cilm_d1,cilm_d2,d_d0,lat_d0,lon_d0)
            threadsafe
            fortranname pyshexpandlsq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),intent(out) :: chi2
            real(dp),dimension(d_d0),intent(in) :: d
            real(dp),dimension(lat_d0),intent(in) :: lat
            real(dp),dimension(lon_d0),intent(in) :: lon
            integer(int32),intent(hide) :: nmax = d_d0
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0=2
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: cilm_d2 = lmax+1
            integer(int32),optional,intent(in),depend(d),intent(hide) :: d_d0 = len(d)
            integer(int32),optional,intent(in),depend(lat),intent(hide) :: lat_d0 = len(lat)
            integer(int32),optional,intent(in),depend(lon),intent(hide) :: lon_d0 = len(lon)
        end subroutine SHExpandLSQ

        subroutine SHExpandWLSQ(exitstatus,cilm,d,w,lat,lon,nmax,lmax,norm,chi2,csphase,cilm_d0,cilm_d1,cilm_d2,d_d0,w_d0,lat_d0,lon_d0)
            threadsafe
            fortranname pyshexpandwlsq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),intent(out) :: chi2
            real(dp),dimension(d_d0),intent(in) :: d
            real(dp),dimension(w_d0),intent(in) :: w
            real(dp),dimension(lat_d0),intent(in) :: lat
            real(dp),dimension(lon_d0),intent(in) :: lon
            integer(int32),intent(hide) :: nmax = d_d0
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0=2
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: cilm_d2 = lmax+1
            integer(int32),optional,intent(in),depend(d),intent(hide) :: d_d0 = len(d)
            integer(int32),optional,intent(in),depend(w),intent(hide) :: w_d0 = len(w)
            integer(int32),optional,intent(in),depend(lat),intent(hide) :: lat_d0 = len(lat)
            integer(int32),optional,intent(in),depend(lon),intent(hide) :: lon_d0 = len(lon)
        end subroutine SHExpandWLSQ

        subroutine G_LSQ(exitstatus,g,lat,lon,nmax,lmax,norm,csphase,g_d0,g_d1,lat_d0,lon_d0)
            threadsafe
            fortranname pyg_lsq
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(g_d0, g_d1),intent(out) :: g
            real(dp),dimension(lat_d0),intent(in) :: lat
            real(dp),dimension(lon_d0),intent(in) :: lon
            integer(int32),intent(hide) :: nmax = g_d0
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(g),intent(hide) :: g_d0 = shape(g,0)
            integer(int32),optional,intent(in),depend(g),intent(hide) :: g_d1 = shape(g,1)
            integer(int32),optional,intent(in),depend(lat),intent(hide) :: lat_d0 = len(lat)
            integer(int32),optional,intent(in),depend(lon),intent(hide) :: lon_d0 = len(lon)
        end subroutine G_LSQ

        function MakeGridPoint(cilm,lmax,lat,lon,norm,csphase,dealloc,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pymakegridpoint
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: dealloc = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            real(dp) :: MakeGridPoint
        end function MakeGridPoint

        function MakeGridPointC(cilm,lmax,lat,lon,norm,csphase,dealloc,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pymakegridpointc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            complex(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in) :: dealloc = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            complex(dp) :: MakeGridPointC
        end function MakeGridPointC

        subroutine SHMultiply(exitstatus,shout,sh1,lmax1,sh2,lmax2,precomp,norm,csphase,sh1_d0,sh1_d1,sh1_d2,sh2_d0,sh2_d1,sh2_d2,shout_d0,shout_d1,shout_d2)
            threadsafe
            fortranname pyshmultiply
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(shout_d0,shout_d1,shout_d2),intent(out) :: shout
            real(dp),dimension(sh1_d0,sh1_d1,sh1_d2),intent(in) :: sh1
            integer(int32),optional,intent(in),depend(sh1_d1) :: lmax1 = sh1_d1-1
            real(dp),dimension(sh2_d0,sh2_d1,sh2_d2),intent(in) :: sh2
            integer(int32),optional,intent(in),depend(sh2_d1) :: lmax2 = sh2_d1-1
            integer(int32),intent(hide) :: precomp = 0
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d0 = shape(sh1,0)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d1 = shape(sh1,1)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d2 = shape(sh1,2)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d0 = shape(sh2,0)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d1 = shape(sh2,1)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d2 = shape(sh2,2)
            integer(int32),optional,intent(in),intent(hide) :: shout_d0 = 2
            integer(int32),optional,intent(in),depend(lmax1,lmax2),intent(hide) :: shout_d1 = lmax1+lmax2+1
            integer(int32),optional,intent(in),depend(lmax1,lmax2),intent(hide) :: shout_d2 = lmax1+lmax2+1
        end subroutine SHMultiply

        subroutine MakeGrid2D(exitstatus,grid,cilm,lmax,interval,nlat,nlong,norm,csphase,f,a,north,south,east,west,dealloc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1)
            threadsafe
            fortranname pymakegrid2d
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(grid_d0,grid_d1),intent(out) :: grid
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: interval
            integer(int32),intent(hide) :: nlat
            integer(int32),intent(hide) :: nlong
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            real(dp),optional,intent(in) :: f = -1.0
            real(dp),optional,intent(in) :: a = -1.0
            real(dp),optional,intent(in) :: north = 90.0
            real(dp),optional,intent(in) :: south = -90.0
            real(dp),optional,intent(in) :: east = 360.0
            real(dp),optional,intent(in) :: west = 0.0
            integer(int32),optional,intent(in) :: dealloc = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(north,south,interval),intent(hide) :: grid_d0 = (north-south)/interval + 1
            integer(int32),optional,intent(in),depend(east,west,interval),intent(hide) :: grid_d1 = (east-west)/interval + 1
        end subroutine MakeGrid2d

        subroutine SHRead2(exitstatus,filename,cilm,lmax,lmax_in,gm,r0_pot,dot,doystart,doyend,epoch,cilm_d0,cilm_d1,cilm_d2,dot_d0,dot_d1,dot_d2)
            threadsafe
            fortranname pyshread2
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            character(*) intent(in) :: filename
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),intent(out) :: lmax
            integer(int32),intent(in) :: lmax_in
            real(dp),intent(out) :: gm
            real(dp),intent(out) :: r0_pot
            real(dp),dimension(dot_d0,dot_d1,dot_d2),intent(out) :: dot
            real(dp),intent(out) :: doystart
            real(dp),intent(out) :: doyend
            real(dp),intent(out) :: epoch
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax_in),check(lmax_in>=0) :: cilm_d1 = lmax_in + 1
            integer(int32),optional,intent(in),intent(hide),depend(cilm_d1) :: cilm_d2 = cilm_d1
            integer(int32),optional,intent(in),intent(hide) :: dot_d0 = 2
            integer(int32),optional,intent(in),depend(cilm_d1),intent(hide) :: dot_d1 = cilm_d1
            integer(int32),optional,intent(in),depend(cilm_d2),intent(hide) :: dot_d2 = cilm_d1
        end subroutine SHRead2

        subroutine SHRead2Error(exitstatus,filename,cilm,error,lmax,lmax_in,gm,r0_pot,dot,doystart,doyend,epoch,cilm_d0,cilm_d1,cilm_d2,error_d0,error_d1,error_d2,dot_d0,dot_d1,dot_d2)
            threadsafe
            fortranname pyshread2error
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            character(*) intent(in) :: filename
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(error_d0,error_d1,error_d2),intent(out) :: error
            integer(int32),intent(out) :: lmax
            integer(int32),intent(in) :: lmax_in
            real(dp),intent(out) :: gm
            real(dp),intent(out) :: r0_pot
            real(dp),dimension(dot_d0,dot_d1,dot_d2),intent(out) :: dot
            real(dp),intent(out) :: doystart
            real(dp),intent(out) :: doyend
            real(dp),intent(out) :: epoch
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax_in),check(lmax_in>=0) :: cilm_d1 = lmax_in+1
            integer(int32),optional,intent(in),intent(hide),depend(cilm_d1) :: cilm_d2 = cilm_d1
            integer(int32),optional,intent(in),intent(hide) :: error_d0 = 2
            integer(int32),optioanl,intent(in),depend(cilm_d1),intent(hide) :: error_d1 = cilm_d1
            integer(int32),optional,intent(in),depend(cilm_d2),intent(hide) :: error_d2 = cilm_d2
            integer(int32),optional,intent(in),intent(hide) :: dot_d0 = 2
            integer(int32),optional,intent(in),depend(cilm_d1),intent(hide) :: dot_d1 = cilm_d1
            integer(int32),optional,intent(in),depend(cilm_d2),intent(hide) :: dot_d2 = cilm_d1
        end subroutine SHRead2Error

        subroutine SHReadJPL(exitstatus,filename,cilm,lmax,lmax_in,gm,formatstring,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pyshreadjpl
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            character(*) intent(in) :: filename
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),intent(out) :: lmax
            integer(int32),intent(out) :: lmax_in
            real(dp),dimension(2),intent(out) :: gm
            character(6),optional,intent(in) :: formatstring = 'E19.12'
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_in),intent(hide),check(lmax_in>=0):: cilm_d1 = lmax_in+1
            integer(int32),optional,intent(in),depend(cilm_d1),intent(hide) :: cilm_d2 = cilm_d1
        end subroutine SHReadJPL

        subroutine SHReadJPLError(exitstatus,filename,cilm,error,lmax,lmax_in,gm,formatstring,cilm_d0,cilm_d1,cilm_d2,error_d0,error_d1,error_d2)
            threadsafe
            fortranname pyshreadjplerror
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            character(*) intent(in) :: filename
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(error_d0,error_d1,error_d2),intent(out) :: error
            integer(int32),intent(out) :: lmax
            integer(int32),intent(out) :: lmax_in
            real(dp),dimension(2),intent(out) :: gm
            character(6),optional,intent(in) :: formatstring = 'E19.12'
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax_in),intent(hide),check(lmax_in>=0):: cilm_d1 = lmax_in+1
            integer(int32),optional,intent(in),depend(cilm_d1),intent(hide) :: cilm_d2 = cilm_d1
            integer(int32),optional,intent(in),intent(hide) :: error_d0 = 2
            integer(int32),optional,intent(in),depend(cilm_d1),intent(hide) :: error_d1 = cilm_d1
            integer(int32),optional,intent(in),depend(cilm_d2),intent(hide) :: error_d2 = cilm_d2
        end subroutine SHReadJPLError

        subroutine SHCilmToVector(exitstatus,cilm,vector,lmax,vector_d0,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pyshcilmtovector
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real(dp),dimension(vector_d0),intent(out) :: vector
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: vector_d0 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
        end subroutine SHCilmToVector

        subroutine SHVectorToCilm(exitstatus,vector,cilm,lmax,vector_d0,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pyshvectortocilm
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(vector_d0),intent(in) :: vector
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),optional,intent(in),depend(vector_d0) :: lmax = sqrt(vector_d0)-1
            integer(int32),optional,intent(in),depend(vector),intent(hide) :: vector_d0 = len(vector)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: cilm_d2 = lmax+1
        end subroutine SHVectorToCilm

        subroutine SHCilmToCindex(exitstatus,cilm,cindex,degmax,cindex_d0,cindex_d1,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pyshcilmtocindex
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real(dp),dimension(cindex_d0,cindex_d1),intent(out) :: cindex
            integer(int32),optional,intent(in),depend(cilm_d1) :: degmax = cilm_d1-1
            integer(int32),optional,intent(in),intent(hide) :: cindex_d0 = 2
            integer(int32),optional,intent(in),depend(degmax),intent(hide),check(degmax>=0) :: cindex_d1 = (degmax+1)*(degmax+2)/2
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
        end subroutine SHCilmToCindex

        subroutine SHCindexToCilm(exitstatus,cindex,cilm,degmax,cindex_d0,cindex_d1,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pyshcindextocilm
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cindex_d0,cindex_d1),intent(in) :: cindex
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            integer(int32),optional,intent(in),depend(cindex_d1) :: degmax = (-3+sqrt(1+8*cindex_d1))/2
            integer(int32),optional,intent(in),depend(cindex),intent(hide) :: cindex_d0 = shape(cindex,0)
            integer(int32),optional,intent(in),depend(cindex),intent(hide) :: cindex_d1 = shape(cindex,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),depend(degmax),intent(hide),check(degmax>=0) :: cilm_d1 = degmax+1
            integer(int32),optional,intent(in),depend(degmax),intent(hide) :: cilm_d2 = degmax+1
        end subroutine SHCindexToCilm

        subroutine SHrtoc(exitstatus,rcilm,ccilm,degmax,convention,switchcs,rcilm_d0,rcilm_d1,rcilm_d2,ccilm_d0,ccilm_d1,ccilm_d2)
            threadsafe
            fortranname pyshrtoc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(rcilm_d0,rcilm_d1,rcilm_d2),intent(in) :: rcilm
            real(dp),dimension(ccilm_d0,ccilm_d1,ccilm_d2),intent(out) :: ccilm
            integer(int32),optional,intent(in),depend(rcilm_d1) :: degmax = rcilm_d1-1
            integer(int32),optional,intent(in) :: convention = 1
            integer(int32),optional,intent(in) :: switchcs = 0
            integer(int32),optional,intent(in),depend(rcilm),intent(hide) :: rcilm_d0 = shape(rcilm,0)
            integer(int32),optional,intent(in),depend(rcilm),intent(hide) :: rcilm_d1 = shape(rcilm,1)
            integer(int32),optional,intent(in),depend(rcilm),intent(hide) :: rcilm_d2 = shape(rcilm,2)
            integer(int32),optional,intent(in),depend(rcilm_d0),intent(hide) :: ccilm_d0 = rcilm_d0
            integer(int32),optional,intent(in),depend(rcilm_d1),intent(hide) :: ccilm_d1 = rcilm_d1
            integer(int32),optional,intent(in),depend(rcilm_d2),intent(hide) :: ccilm_d2 = rcilm_d2
        end subroutine SHrtoc

        subroutine SHctor(exitstatus,ccilm,rcilm,degmax,convention,switchcs,rcilm_d0,rcilm_d1,rcilm_d2,ccilm_d0,ccilm_d1,ccilm_d2)
            threadsafe
            fortranname pyshctor
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(ccilm_d0,ccilm_d1,ccilm_d2),intent(in) :: ccilm
            real(dp),dimension(rcilm_d0,rcilm_d1,rcilm_d2),intent(out) :: rcilm
            integer(int32),optional,intent(in),depend(ccilm_d1) :: degmax = ccilm_d1-1
            integer(int32),optional,intent(in) :: convention = 1
            integer(int32),optional,intent(in) :: switchcs = 0
            integer(int32),optional,intent(in),depend(ccilm_d0),intent(hide) :: rcilm_d0 = ccilm_d0
            integer(int32),optional,intent(in),depend(ccilm_d1),intent(hide) :: rcilm_d1 = ccilm_d1
            integer(int32),optional,intent(in),depend(ccilm_d2),intent(hide) :: rcilm_d2 = ccilm_d2
            integer(int32),optional,intent(in),depend(ccilm),intent(hide) :: ccilm_d0 = shape(ccilm,0)
            integer(int32),optional,intent(in),depend(ccilm),intent(hide) :: ccilm_d1 = shape(ccilm,1)
            integer(int32),optional,intent(in),depend(ccilm),intent(hide) :: ccilm_d2 = shape(ccilm,2)
        end subroutine SHctor

        subroutine djpi2(exitstatus,dj,lmax,dj_d0,dj_d1,dj_d2)
            threadsafe
            fortranname pydjpi2
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(dj_d0,dj_d1,dj_d2),intent(out) :: dj
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: dj_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: dj_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: dj_d2 = lmax+1
        end subroutine djpi2

        subroutine SHRotateCoef(exitstatus,x,cof,rcof,dj,lmax,rcof_d0,rcof_d1,dj_d0,dj_d1,dj_d2,cof_d0,cof_d1)
            threadsafe
            fortranname pyshrotatecoef
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(3),intent(in) :: x
            real(dp),dimension(cof_d0,cof_d1),intent(in) :: cof
            real(dp),dimension(dj_d0,dj_d1,dj_d2),intent(in) :: dj
            real(dp),dimension(rcof_d0,rcof_d1),intent(out) :: rcof
            integer(int32),optional,intent(in),depend(cof_d1) :: lmax = (-3+sqrt(1+8*cof_d1))/2
            integer(int32),optional,intent(in),intent(hide) :: rcof_d0 = 2
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: rcof_d1 = (lmax+1)*(lmax+2)/2
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d0 = shape(dj,0)
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d1 = shape(dj,1)
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d2 = shape(dj,2)
            integer(int32),optional,intent(in),depend(cof),intent(hide) :: cof_d0 = shape(cof,0)
            integer(int32),optional,intent(in),depend(cof),intent(hide) :: cof_d1 = shape(cof,1)
        end subroutine SHRotateCoef

        subroutine SHRotateRealCoef(exitstatus,cilmrot,cilm,lmax,x,dj,x_d0,dj_d0,dj_d1,dj_d2,cilm_d0,cilm_d1,cilm_d2,cilmrot_d0,cilmrot_d1,cilmrot_d2)
            threadsafe
            fortranname pyshrotaterealcoef
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real(dp),dimension(cilmrot_d0,cilmrot_d1,cilmrot_d2),intent(out) :: cilmrot
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),dimension(x_d0),intent(in) :: x
            real(dp),dimension(dj_d0,dj_d1,dj_d2),intent(in) :: dj
            integer(int32),optional,intent(in),depend(x),intent(hide) :: x_d0 = len(x)
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d0 = shape(dj,0)
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d1 = shape(dj,1)
            integer(int32),optional,intent(in),depend(dj),intent(hide) :: dj_d2 = shape(dj,2)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: cilmrot_d0 = 2
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: cilmrot_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: cilmrot_d2 = lmax+1
        end subroutine SHRotateRealCoef

        subroutine SHAdmitCorr(exitstatus,G,T,lmax,admit,admit_error,corr,G_d0,G_d1,G_d2,admit_d0,admit_error_d0,T_d0,T_d1,T_d2,corr_d0)
            threadsafe
            fortranname pyshadmitcorr
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(G_d0,G_d1,G_d2),intent(in) :: G
            real(dp),dimension(T_d0,T_d1,T_d2),intent(in) :: T
            integer(int32),optional,intent(in),depend(G_d1,T_d1) :: lmax = min(G_d1,T_d1)-1
            real(dp),dimension(admit_d0),intent(out) :: admit
            real(dp),dimension(admit_error_d0),intent(out) :: admit_error
            real(dp),dimension(corr_d0),intent(out) :: corr
            integer(int32),optional,intent(in),depend(G),intent(hide) :: G_d0 = shape(G,0)
            integer(int32),optional,intent(in),depend(G),intent(hide) :: G_d1 = shape(G,1)
            integer(int32),optional,intent(in),depend(G),intent(hide) :: G_d2 = shape(G,2)
            integer(int32),optional,intent(in),depend(T),intent(hide) :: T_d0 = shape(T,0)
            integer(int32),optional,intent(in),depend(T),intent(hide) :: T_d1 = shape(T,1)
            integer(int32),optional,intent(in),depend(T),intent(hide) :: T_d2 = shape(T,2)
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: admit_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: admit_error_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: corr_d0 = lmax+1
        end subroutine SHAdmitCorr

        function SHConfidence(l_conf,r)
            threadsafe
            fortranname pyshconfidence
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(in) :: l_conf
            real(dp),intent(in) :: r
            real(dp) :: SHConfidence
        end function SHConfidence

        subroutine SHMultiTaperSE(exitstatus,mtse,sd,sh,lmax,tapers,taper_order,lmaxt,k,lat,lon,taper_wt,norm,csphase,taper_order_d0,taper_wt_d0,sh_d0,sh_d1,sh_d2,tapers_d0,tapers_d1,mtse_d0,sd_d0)
            threadsafe
            fortranname pyshmultitaperse
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(mtse_d0),intent(out) :: mtse
            real(dp),dimension(sd_d0),intent(out) :: sd
            real(dp),dimension(sh_d0,sh_d1,sh_d2),intent(in) :: sh
            integer(int32),optional,intent(in),depend(sh_d1) :: lmax = sh_d1-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            integer(int32),optional,intent(in),depend(tapers_d0) :: lmaxt = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),optional,intent(in) :: lat = 0.0
            real(dp),optional,intent(in) :: lon = 0.0
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1.0
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(taper_order),intent(hide) :: taper_order_d0 = len(taper_order)
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d0 = shape(sh,0)
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d1 = shape(sh,1)
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d2 = shape(sh,2)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(lmax,lmaxt),intent(hide) :: mtse_d0 = lmax-lmaxt+1
            integer(int32),optional,intent(in),depend(lmax,lmaxt),intent(hide) :: sd_d0 = lmax-lmaxt+1
        end subroutine SHMultiTaperSE

        subroutine SHMultiTaperCSE(exitstatus,mtse,sd,sh1,lmax1,sh2,lmax2,tapers,taper_order,lmaxt,k,lat,lon,taper_wt,norm,csphase,sh1_d0,sh1_d1,sh1_d2,sh2_d0,sh2_d1,sh2_d2,taper_order_d0,taper_wt_d0,tapers_d0,tapers_d1,sd_d0,mtse_d0)
            threadsafe
            fortranname pyshmultitapercse
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(mtse_d0),intent(out) :: mtse
            real(dp),dimension(sd_d0),intent(out) :: sd
            real(dp),dimension(sh1_d0,sh1_d1,sh1_d2),intent(in) :: sh1
            integer(int32),optional,intent(in),depend(sh1_d1) :: lmax1 = sh1_d1-1
            real(dp),dimension(sh2_d0,sh2_d1,sh2_d2),intent(in) :: sh2
            integer(int32),optional,intent(in),depend(sh2_d1) :: lmax2 = sh2_d1-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            integer(int32),optional,intent(in),depend(tapers_d0) :: lmaxt = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),optional,intent(in) :: lat = 0.0
            real(dp),optional,intent(in) :: lon = 0.0
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1.0
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d0 = shape(sh1,0)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d1 = shape(sh1,1)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d2 = shape(sh1,2)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d0 = shape(sh2,0)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d1 = shape(sh2,1)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d2 = shape(sh2,2)
            integer(int32),optional,intent(in),depend(taper_order),intent(hide) :: taper_order_d0 = len(taper_order)
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(lmax1,lmax2,lmaxt),intent(hide) :: sd_d0 = min(lmax1,lmax2)-lmaxt+1
            integer(int32),optional,intent(in),depend(lmax1,lmax2,lmaxt),intent(hide) :: mtse_d0 = min(lmax1,lmax2)-lmaxt+1
        end subroutine SHMultiTaperCSE

        subroutine SHLocalizedAdmitCorr(exitstatus,g,t,tapers,taper_order,k,lat,lon,lwin,lmax,admit,corr,admit_error,corr_error,taper_wt,mtdef,k1linsig,taper_order_d0,g_d0,g_d1,g_d2,taper_wt_d0,corr_error_d0,admit_d0,admit_error_d0,corr_d0,tapers_d0,tapers_d1,t_d0,t_d1,t_d2)
            threadsafe
            fortranname pyshlocalizedadmitcorr
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(g_d0,g_d1,g_d2),intent(in) :: g
            real(dp),dimension(t_d0,t_d1,t_d2),intent(in) :: t
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer(int32),optional,intent(in),depend(t_d1,g_d1) :: lmax = min(t_d1-1,g_d1-1)
            real(dp),dimension(admit_d0),intent(out) :: admit
            real(dp),dimension(corr_d0),intent(out),depend(corr_d0) :: corr
            real(dp),dimension(admit_error_d0),intent(out) :: admit_error
            real(dp),dimension(corr_error_d0),intent(out) :: corr_error
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1.0
            integer(int32),optional,intent(in) :: mtdef = 1
            integer(int32),optional,intent(in) :: k1linsig = -1
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(taper_order),intent(hide) :: taper_order_d0 = len(taper_order)
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(g),intent(hide) :: g_d0 = shape(g,0)
            integer(int32),optional,intent(in),depend(g),intent(hide) :: g_d1 = shape(g,1)
            integer(int32),optional,intent(in),depend(g),intent(hide) :: g_d2 = shape(g,2)
            integer(int32),optional,intent(in),depend(t),intent(hide) :: t_d0 = shape(t,0)
            integer(int32),optional,intent(in),depend(t),intent(hide) :: t_d1 = shape(t,1)
            integer(int32),optional,intent(in),depend(t),intent(hide) :: t_d2 = shape(t,2)
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: corr_error_d0 = lmax-lwin+1
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: admit_d0 = lmax-lwin+1
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: admit_error_d0 = lmax-lwin+1
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: corr_d0 = lmax-lwin+1
        end subroutine SHLocalizedAdmitCorr

        subroutine SHReturnTapers(exitstatus,theta0,lmax,tapers,eigenvalues,taper_order,degrees,eigenvalues_d0,tapers_d0,tapers_d1,taper_order_d0,degrees_d0)
            threadsafe
            fortranname pyshreturntapers
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),intent(in) :: theta0
            integer(int32),intent(in) :: lmax
            real(dp),dimension(tapers_d0,tapers_d1),intent(out) :: tapers
            real(dp),dimension(eigenvalues_d0),intent(out) :: eigenvalues
            integer(int32),dimension(taper_order_d0),intent(out) :: taper_order
            integer(int32),optional,intent(in),dimension(degrees_d0) :: degrees = 1
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: eigenvalues_d0 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: tapers_d0 = (lmax+1)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: tapers_d1 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: taper_order_d0 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: degrees_d0 = lmax+1
        end subroutine SHReturnTapers

        subroutine SHReturnTapersM(exitstatus,theta0,lmax,m,tapers,eigenvalues,degrees,tapers_d0,tapers_d1,eigenvalues_d0,degrees_d0)
            threadsafe
            fortranname pyshreturntapersm
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),intent(in) :: theta0
            integer(int32),intent(in) :: lmax
            integer(int32),intent(in) :: m
            real(dp),dimension(tapers_d0,tapers_d1),intent(out) :: tapers
            real(dp),dimension(eigenvalues_d0),intent(out) :: eigenvalues
            integer(int32),optional,intent(in),dimension(degrees_d0) :: degrees = 1
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: tapers_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: tapers_d1 = lmax+1-abs(m)
            integer(int32),optional,intent(in),depend(degrees),intent(hide) :: eigenvalues_d0 = lmax+1-abs(m)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: degrees_d0 = lmax+1
        end subroutine SHReturnTapersM

        subroutine ComputeDm(exitstatus,dllm,lmax,m,theta0,degrees,dllm_d0,dllm_d1,degrees_d0)
            threadsafe
            fortranname pycomputedm
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(dllm_d0,dllm_d1),intent(out) :: dllm
            integer(int32),intent(in) :: lmax
            integer(int32),intent(in) :: m
            real(dp),intent(in) :: theta0
            integer(int32),optional,intent(in),dimension(degrees_d0) :: degrees = 1
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: dllm_d0 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: dllm_d1 = lmax+1
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: degrees_d0 = lmax+1
        end subroutine ComputeDm

        subroutine ComputeDG82(exitstatus,dG82,lmax,m,theta0,dG82_d0,dG82_d1)
            threadsafe
            fortranname pycomputedg82
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(dG82_d0,dG82_d1),intent(out) :: dG82
            integer(int32),intent(in) :: lmax
            integer(int32),intent(in) :: m
            real(dp),intent(in) :: theta0
            integer(int32),optional,intent(in),depend(lmax,m),intent(hide) :: dG82_d0 = lmax-abs(m)+1
            integer(int32),optional,intent(in),depend(lmax,m),intent(hide) :: dG82_d1 = lmax-abs(m)+1
        end subroutine ComputeDG82

        function SHFindLWin(theta0,m,alpha,taper_number)
            threadsafe
            fortranname pyshfindlwin
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            real(dp),intent(in) :: theta0
            integer(int32),intent(in) :: m
            real(dp),intent(in) :: alpha
            integer(int32),optional,intent(in) :: taper_number = 1
            integer(int32) :: SHFindLWin
        end function SHFindLWin

        subroutine SHBiasK(exitstatus,tapers,lwin,k,incspectra,ldata,outcspectra,taper_wt,save_cg,taper_wt_d0,tapers_d0,tapers_d1,incspectra_d0,outcspectra_d0)
            threadsafe
            fortranname pyshbiask
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),dimension(incspectra_d0),intent(in) :: incspectra
            integer(int32),optional,intent(in),depend(incspectra_d0) :: ldata = incspectra_d0-1
            real(dp),dimension(outcspectra_d0),intent(out) :: outcspectra
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,intent(in) :: save_cg = 0
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(incspectra),intent(hide) :: incspectra_d0 = len(incspectra)
            integer(int32),optional,intent(in),depend(ldata,lwin),intent(hide) :: outcspectra_d0 = ldata+lwin+1
        end subroutine SHBiasK

        subroutine SHMTCouplingMatrix(exitstatus,Mmt,lmax,tapers_power,lwin,k,taper_wt,Mmt_d0,Mmt_d1,tapers_power_d0,tapers_power_d1,taper_wt_d0)
            threadsafe
            fortranname pyshmtcouplingmatrix
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(Mmt_d0,Mmt_d1),intent(out) :: Mmt
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in),depend(tapers_power_d1) :: k = tapers_power_d1
            integer(int32),optional,intent(in),depend(tapers_power_d0) :: lwin = tapers_power_d0-1
            real(dp),intent(in) :: tapers_power(tapers_power_d0,tapers_power_d1)
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,depend(lmax,lwin),intent(hide) :: Mmt_d0 = lmax+lwin+1
            integer(int32),optional,depend(lmax),intent(hide),check(lmax>=0) :: Mmt_d1 = lmax+1
            integer(int32),optional,depend(tapers_power),intent(hide) :: tapers_power_d0 = shape(tapers_power,0)
            integer(int32),optional,depend(tapers_power),intent(hide) :: tapers_power_d1 = shape(tapers_power,1)
            integer(int32),optional,depend(tapers_power_d1),intent(hide) :: taper_wt_d0 = tapers_power_d1
        end subroutine

        subroutine SHBiasAdmitCorr(exitstatus,sgt,sgg,stt,lmax,tapers,lwin,k,admit,corr,mtdef,taper_wt,taper_wt_d0,sgt_d0,stt_d0,admit_d0,tapers_d0,tapers_d1,corr_d0,sgg_d0)
            threadsafe
            fortranname pyshbiasadmitcorr
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(admit_d0),intent(out) :: admit
            real(dp),dimension(corr_d0),intent(out) :: corr
            real(dp),dimension(sgt_d0),intent(in) :: sgt
            real(dp),dimension(sgg_d0),intent(in) :: sgg
            real(dp),dimension(stt_d0),intent(in) :: stt
            integer(int32),optional,intent(in),depend(sgt_d0) :: lmax = sgt_d0-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            integer(int32),optional,intent(in) :: mtdef = 1
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(sgt),intent(hide) :: sgt_d0 = len(sgt)
            integer(int32),optional,intent(in),depend(stt),intent(hide) :: stt_d0 = len(stt)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(sgg),intent(hide) :: sgg_d0 = len(sgg)
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: corr_d0 = lmax-lwin+1
            integer(int32),optional,intent(in),depend(lmax,lwin),intent(hide) :: admit_d0 = lmax-lwin+1
        end subroutine SHBiasAdmitCorr

        subroutine SHMTDebias(exitstatus,mtdebias,mtspectra,lmax,tapers,lwin,k,nl,lmid,n,taper_wt,mtdebias_d0,mtdebias_d1,taper_wt_d0,mtspectra_d0,mtspectra_d1,tapers_d0,tapers_d1,lmid_d0)
            threadsafe
            fortranname pyshmtdebias
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(mtdebias_d0,mtdebias_d1),intent(out) :: mtdebias
            real(dp),dimension(lmid_d0),intent(out) :: lmid
            integer(int32),intent(hide) :: n
            real(dp),dimension(mtspectra_d0,mtspectra_d1),intent(in) :: mtspectra
            integer(int32),optional,intent(in),depend(mtspectra_d1) :: lmax = mtspectra_d1-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            integer(int32),intent(in) :: nl
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,intent(in),intent(hide) :: mtdebias_d0 = 2
            integer(int32),optional,intent(in),depend(lmid_d0),intent(hide) :: mtdebias_d1 = lmid_d0
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(mtspectra),intent(hide) :: mtspectra_d0 = shape(mtspectra,0)
            integer(int32),optional,intent(in),depend(mtspectra),intent(hide) :: mtspectra_d1 = shape(mtspectra,1)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(lmax,nl),intent(hide) :: lmid_d0 = (int)(ceil((float)(lmax+1)/(float)nl))
        end subroutine SHMTDebias

        subroutine SHMTVarOpt(exitstatus,l,tapers,taper_order,lwin,kmax,Sff,var_opt,var_unit,weight_opt,nocross,taper_order_d0,weight_opt_d0,weight_opt_d1,var_unit_d0,var_opt_d0,Sff_d0,tapers_d0,tapers_d1)
            threadsafe
            fortranname pyshmtvaropt
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            integer(int32),intent(in) :: l
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: kmax = tapers_d1
            real(dp),dimension(Sff_d0),intent(in) :: Sff
            real(dp),dimension(var_opt_d0),intent(out) :: var_opt
            real(dp),dimension(var_unit_d0),intent(out) :: var_unit
            real(dp),dimension(weight_opt_d0,weight_opt_d1),intent(out) :: weight_opt
            integer(int32),optional,intent(in) :: nocross = 0
            integer(int32),optional,intent(in),depend(taper_order),intent(hide) :: taper_order_d0 = len(taper_order)
            integer(int32),intent(in),depend(kmax),intent(hide) :: weight_opt_d0 = kmax
            integer(int32),intent(in),depend(kmax),intent(hide) :: weight_opt_d1 = kmax
            integer(int32),intent(in),depend(kmax),intent(hide) :: var_unit_d0 = kmax
            integer(int32),intent(in),depend(kmax),intent(hide) :: var_opt_d0 = kmax
            integer(int32),optional,intent(in),depend(Sff),intent(hide) :: Sff_d0 = len(Sff)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
        end subroutine SHMTVarOpt

        subroutine SHMTVar(exitstatus,l,tapers,taper_order,Sff,kmax,lwin,variance,taper_wt,nocross,taper_order_d0,taper_wt_d0,Sff_d0,tapers_d0,tapers_d1)
            threadsafe
            fortranname pyshmtvar
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            integer(int32),intent(in) :: l
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            real(dp),dimension(Sff_d0),intent(in) :: Sff
            integer(int32),optional,intent(in),depend(tapers_d1) :: kmax = tapers_d1
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            real(dp),intent(out) :: variance
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,intent(in) :: nocross = 0
            integer(int32),optional,intent(in),depend(taper_order),intent(hide) :: taper_order_d0 = len(taper_order)
            integer(int32),optional,intent(in),depend(kmax),intent(hide) :: taper_wt_d0 = kmax
            integer(int32),optional,intent(in),depend(Sff),intent(hide) :: Sff_d0 = len(Sff)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
        end subroutine SHMTVar

        function SHSjkPG(incspectra,l,m,mprime,hj_real,hk_real,mj,mk,lwin,hkcc,hk_real_d0,incspectra_d0,hj_real_d0)
            threadsafe
            fortranname pyshsjkpg
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            real(dp),dimension(incspectra_d0),intent(in) :: incspectra
            integer(int32),intent(in) :: l
            integer(int32),intent(in) :: m
            integer(int32),intent(in) :: mprime
            real(dp),dimension(hj_real_d0),intent(in) :: hj_real
            real(dp),dimension(hk_real_d0),intent(in) :: hk_real
            integer(int32),intent(in) :: mj
            integer(int32),intent(in) :: mk
            integer(int32),intent(in) :: lwin
            integer(int32),intent(in) :: hkcc
            integer(int32),optional,intent(in),depend(hk_real),intent(hide) :: hk_real_d0 = len(hk_real)
            integer(int32),optional,intent(in),depend(incspectra),intent(hide) :: incspectra_d0 = len(incspectra)
            integer(int32),optional,intent(in),depend(hj_real),intent(hide) :: hj_real_d0 = len(hj_real)
            complex(dp) :: SHSjkPG
        end function SHSjkPG

        subroutine SHReturnTapersMap(exitstatus,tapers,eigenvalues,dh_mask,n_dh,lmax,sampling,ntapers,degrees,dh_mask_d0,dh_mask_d1,tapers_d0,tapers_d1,eigenvalues_d0,degrees_d0)
            threadsafe
            fortranname pyshreturntapersmap
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(tapers_d0,tapers_d1),intent(out) :: tapers
            real(dp),dimension(eigenvalues_d0),intent(out) :: eigenvalues
            integer(int32),dimension(dh_mask_d0,dh_mask_d1),intent(in) :: dh_mask
            integer(int32),optional,intent(in),depend(dh_mask_d0) :: n_dh = dh_mask_d0
            integer(int32),optional,intent(in),depend(dh_mask_d1,dh_mask_d0) :: sampling = dh_mask_d1/dh_mask_d0
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in),depend(lmax) :: ntapers = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),dimension(degrees_d0) :: degrees = 1
            integer(int32),optional,intent(in),depend(dh_mask),intent(hide) :: dh_mask_d0 = shape(dh_mask,0)
            integer(int32),optional,intent(in),depend(dh_mask),intent(hide) :: dh_mask_d1 = shape(dh_mask,1)
            integer(int32),intent(in),depend(lmax),intent(hide),check(lmax>=0) :: tapers_d0 = (lmax+1)*(lmax+1)
            integer(int32),intent(in),depend(ntapers),intent(hide) :: tapers_d1 = ntapers
            integer(int32),intent(in),depend(ntapers),intent(hide) :: eigenvalues_d0 = ntapers
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: degrees_d0 = lmax+1
        end subroutine SHReturnTapersMap

        subroutine SHBiasKMask(exitstatus,tapers,lwin,k,incspectra,ldata,outcspectra,taper_wt,save_cg,taper_wt_d0,tapers_d0,tapers_d1,incspectra_d0,outcspectra_d0)
            threadsafe
            fortranname pyshbiaskmask
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lwin = sqrt(tapers_d0)-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),dimension(incspectra_d0),intent(in) :: incspectra
            integer(int32),optional,intent(in),depend(incspectra_d0) :: ldata = incspectra_d0-1
            real(dp),dimension(outcspectra_d0),intent(out) :: outcspectra
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer(int32),optional,intent(in) :: save_cg = 0
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(incspectra),intent(hide) :: incspectra_d0 = len(incspectra)
            integer(int32),optional,intent(in),depend(ldata,lwin),intent(hide) :: outcspectra_d0 = ldata+lwin+1
        end subroutine SHBiasKMask

        subroutine SHMultiTaperMaskSE(exitstatus,mtse,sd,sh,lmax,tapers,lmaxt,k,taper_wt,norm,csphase,taper_wt_d0,sh_d0,sh_d1,sh_d2,tapers_d0,tapers_d1,mtse_d0,sd_d0)
            threadsafe
            fortranname pyshmultitapermaskse
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(mtse_d0),intent(out) :: mtse
            real(dp),dimension(sd_d0),intent(out) :: sd
            real(dp),dimension(sh_d0,sh_d1,sh_d2),intent(in) :: sh
            integer(int32),optional,intent(in),depend(sh_d1) :: lmax = sh_d1-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lmaxt = sqrt(tapers_d0)-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1.0
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d0 = shape(sh,0)
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d1 = shape(sh,1)
            integer(int32),optional,intent(in),depend(sh),intent(hide) :: sh_d2 = shape(sh,2)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(lmax,lmaxt),intent(hide) :: mtse_d0 = lmax-lmaxt+1
            integer(int32),optional,intent(in),depend(lmax,lmaxt),intent(hide) :: sd_d0 = lmax-lmaxt+1
        end subroutine SHMultiTaperMaskSE

        subroutine SHMultiTaperMaskCSE(exitstatus,mtse,sd,sh1,lmax1,sh2,lmax2,tapers,lmaxt,k,taper_wt,norm,csphase,sh1_d0,sh1_d1,sh1_d2,sh2_d0,sh2_d1,sh2_d2,taper_wt_d0,tapers_d0,tapers_d1,sd_d0,mtse_d0)
            threadsafe
            fortranname pyshmultitapermaskcse
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(mtse_d0),intent(out) :: mtse
            real(dp),dimension(sd_d0),intent(out) :: sd
            real(dp),dimension(sh1_d0,sh1_d1,sh1_d2),intent(in) :: sh1
            integer(int32),optional,intent(in),depend(sh1_d1) :: lmax1 = sh1_d1-1
            real(dp),dimension(sh2_d0,sh2_d1,sh2_d2),intent(in) :: sh2
            integer(int32),optional,intent(in),depend(sh2_d1) :: lmax2 = sh2_d1-1
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),optional,intent(in),depend(tapers_d0) :: lmaxt = sqrt(tapers_d0)-1
            integer(int32),optional,intent(in),depend(tapers_d1) :: k = tapers_d1
            real(dp),optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1.0
            integer(int32),optional,intent(in) :: norm = 1
            integer(int32),optional,intent(in) :: csphase = 1
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d0 = shape(sh1,0)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d1 = shape(sh1,1)
            integer(int32),optional,intent(in),depend(sh1),intent(hide) :: sh1_d2 = shape(sh1,2)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d0 = shape(sh2,0)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d1 = shape(sh2,1)
            integer(int32),optional,intent(in),depend(sh2),intent(hide) :: sh2_d2 = shape(sh2,2)
            integer(int32),optional,intent(in),depend(tapers_d1),intent(hide) :: taper_wt_d0 = tapers_d1
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),depend(tapers),intent(hide) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),depend(lmax1,lmax2,lmaxt),intent(hide) :: sd_d0 = min(lmax1,lmax2)-lmaxt+1
            integer(int32),optional,intent(in),depend(lmax1,lmax2,lmaxt),intent(hide) :: mtse_d0 = min(lmax1,lmax2)-lmaxt+1
        end subroutine SHMultiTaperMaskCSE

        subroutine ComputeDMap(exitstatus,Dij,dh_mask,n_dh,lmax,sampling,degrees,dh_mask_d0,dh_mask_d1,Dij_d0,Dij_d1,degrees_d0)
            threadsafe
            fortranname pycomputedmap
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(Dij_d0,Dij_d1),intent(out) :: Dij
            integer(int32),dimension(dh_mask_d0,dh_mask_d1),intent(in) :: dh_mask
            integer(int32),optional,intent(in),depend(dh_mask_d0) :: n_dh = dh_mask_d0
            integer(int32),optional,intent(in),depend(dh_mask_d0,dh_mask_d1):: sampling = dh_mask_d1/dh_mask_d0
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in),dimension(degrees_d0) :: degrees = 1
            integer(int32),optional,intent(in),depend(dh_mask),intent(hide) :: dh_mask_d0 = shape(dh_mask,0)
            integer(int32),optional,intent(in),depend(dh_mask),intent(hide) :: dh_mask_d1 = shape(dh_mask,1)
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: Dij_d0 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),depend(lmax),intent(hide) :: Dij_d1 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),intent(hide) :: degrees_d0 = lmax+1
        end subroutine ComputeDMap

        subroutine Curve2Mask(exitstatus,dhgrid,n,sampling,profile,nprofile,NP,extend,profile_d0,profile_d1,dhgrid_d0,dhgrid_d1)
            threadsafe
            fortranname pycurve2mask
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            integer(int32),dimension(dhgrid_d0,dhgrid_d1),intent(out) :: dhgrid
            integer(int32),intent(in) :: n
            integer(int32),optional,intent(in) :: sampling = 1
            real(dp),dimension(profile_d0,profile_d1),intent(in) :: profile
            integer(int32),optional,intent(in),depend(profile_d0) :: nprofile = profile_d0
            integer(int32),intent(in):: NP
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(profile),intent(hide) :: profile_d0 = shape(profile,0)
            integer(int32),optional,intent(in),depend(profile),intent(hide) :: profile_d1 = shape(profile,1)
            integer(int32),optional,intent(in),depend(n,extend),intent(hide) :: dhgrid_d0 = n+extend
            integer(int32),optional,intent(in),depend(n,sampling,extend),intent(hide) :: dhgrid_d1 = n*sampling+extend
        end subroutine Curve2Mask

        subroutine SHBias(exitstatus,Shh,lwin,incspectra,ldata,outcspectra,save_cg,Shh_d0,incspectra_d0,outcspectra_d0)
            threadsafe
            fortranname pyshbias
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(Shh_d0),intent(in) :: Shh
            integer(int32),optional,intent(in),depend(Shh_d0) :: lwin = Shh_d0-1
            real(dp),dimension(incspectra_d0),intent(in) :: incspectra
            integer(int32),optional,intent(in),depend(incspectra_d0) :: ldata = incspectra_d0-1
            real(dp),dimension(outcspectra_d0),intent(out) :: outcspectra
            integer(int32),optional,intent(in) :: save_cg = 0
            integer(int32),optional,intent(in),depend(Shh),intent(hide) :: Shh_d0 = len(Shh)
            integer(int32),optional,intent(in),depend(incspectra),intent(hide) :: incspectra_d0 = len(incspectra)
            integer(int32),optional,intent(in),depend(ldata,lwin),intent(hide) :: outcspectra_d0 = ldata+lwin+1
        end subroutine SHBias

        subroutine SphericalCapCoef(exitstatus,coef,theta,lmax,coef_d0)
            threadsafe
            fortranname pysphericalcapcoef
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(coef_d0),intent(out) :: coef
            real(dp),intent(in) :: theta
            integer(int32),intent(in) :: lmax
            integer(int32),optional,intent(in),depend(lmax),intent(hide),check(lmax>=0) :: coef_d0 = lmax+1
        end subroutine SphericalCapCoef

        subroutine MakeGravGridDH(exitstatus,cilm,lmax,gm,r0,a,f,rad,theta,phi,total,pot,n,sampling,lmax_calc,omega,normal_gravity,extend,phi_d0,phi_d1,total_d0,total_d1,rad_d0,rad_d1,cilm_d0,cilm_d1,cilm_d2,theta_d0,theta_d1,pot_d0,pot_d1)
            threadsafe
            fortranname pymakegravgriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: gm
            real(dp),intent(in) :: r0
            real(dp),optional,intent(in),depend(r0) :: a = r0
            real(dp),optional,intent(in) :: f = 0.0
            real(dp),dimension(rad_d0,rad_d1),intent(out) :: rad
            real(dp),dimension(theta_d0,theta_d1),intent(out) :: theta
            real(dp),dimension(phi_d0,phi_d1),intent(out) :: phi
            real(dp),dimension(total_d0,total_d1),intent(out) :: total
            real(dp),dimension(pot_d0,pot_d1),intent(out) :: pot
            integer(int32),intent(hide) :: n
            integer(int32),optional,intent(in) :: sampling = 2
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            real(dp),optional,intent(in) :: omega = 0.0
            integer(int32),optional,intent(in) :: normal_gravity = 1
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),intent(in),intent(hide),depend(lmax,extend),check(lmax>=0) :: phi_d0 = 2*(lmax+1)+extend
            integer(int32),intent(in),intent(hide),depend(sampling,lmax,extend) :: phi_d1 = sampling*2*(lmax+1)+extend
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: total_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: total_d1 = phi_d1
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: rad_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: rad_d1 = phi_d1
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: theta_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: theta_d1 = phi_d1
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: pot_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: pot_d1 = phi_d1
        end subroutine MakeGravGridDH

        subroutine MakeGravGridPoint(vec,cilm,lmax,gm,r0,r,lat,lon,omega,dealloc,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pymakegravgridpoint
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: gm
            real(dp),intent(in) :: r0
            real(dp),intent(in) :: r
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            real(dp),optional,intent(in) :: omega = 0.0
            integer(int32),optional,intent(in) :: dealloc = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            real(dp),dimension(3),intent(out) :: vec
        end subroutine MakeGravGridPoint

        subroutine MakeGravGradGridDH(exitstatus,cilm,lmax,gm,r0,a,f,vxx,vyy,vzz,vxy,vxz,vyz,n,sampling,lmax_calc,extend,vyz_d0,vyz_d1,vyy_d0,vyy_d1,cilm_d0,cilm_d1,cilm_d2,vzz_d0,vzz_d1,vxy_d0,vxy_d1,vxx_d0,vxx_d1,vxz_d0,vxz_d1)
            threadsafe
            fortranname pymakegravgradgriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: gm
            real(dp),intent(in) :: r0
            real(dp),optional,intent(in) :: a = r0
            real(dp),optional,intent(in) :: f = 0
            real(dp),dimension(vxx_d0,vxx_d1),intent(out) :: vxx
            real(dp),dimension(vyy_d0,vyy_d1),intent(out) :: vyy
            real(dp),dimension(vzz_d0,vzz_d1),intent(out) :: vzz
            real(dp),dimension(vxy_d0,vxy_d1),intent(out) :: vxy
            real(dp),dimension(vxz_d0,vxz_d1),intent(out) :: vxz
            real(dp),dimension(vyz_d0,vyz_d1),intent(out) :: vyz
            integer(int32),intent(hide) :: n
            integer(int32),optional,intent(in) :: sampling = 2
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide),check(lmax>=0) :: vyz_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(sampling,lmax,extend),intent(hide) :: vyz_d1 = sampling*2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vyy_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vyy_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vzz_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vzz_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxy_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxy_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxx_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxx_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxz_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxz_d1 = vyz_d1
        end subroutine MakeGravGradGridDH

        subroutine MakeMagGradGridDH(exitstatus,cilm,lmax,r0,a,f,vxx,vyy,vzz,vxy,vxz,vyz,n,sampling,lmax_calc,extend,vyz_d0,vyz_d1,vyy_d0,vyy_d1,cilm_d0,cilm_d1,cilm_d2,vzz_d0,vzz_d1,vxy_d0,vxy_d1,vxx_d0,vxx_d1,vxz_d0,vxz_d1)
            threadsafe
            fortranname pymakemaggradgriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: r0
            real(dp),optional,intent(in) :: a = r0
            real(dp),optional,intent(in) :: f = 0
            real(dp),dimension(vxx_d0,vxx_d1),intent(out) :: vxx
            real(dp),dimension(vyy_d0,vyy_d1),intent(out) :: vyy
            real(dp),dimension(vzz_d0,vzz_d1),intent(out) :: vzz
            real(dp),dimension(vxy_d0,vxy_d1),intent(out) :: vxy
            real(dp),dimension(vxz_d0,vxz_d1),intent(out) :: vxz
            real(dp),dimension(vyz_d0,vyz_d1),intent(out) :: vyz
            integer(int32),intent(hide) :: n
            integer(int32),optional,intent(in) :: sampling = 2
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide),check(lmax>=0) :: vyz_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(sampling,lmax,extend),intent(hide) :: vyz_d1 = sampling*2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vyy_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vyy_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 =shape(cilm,2)
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vzz_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vzz_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxy_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxy_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxx_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxx_d1 = vyz_d1
            integer(int32),optional,intent(in),depend(vyz_d0),intent(hide) :: vxz_d0 = vyz_d0
            integer(int32),optional,intent(in),depend(vyz_d1),intent(hide) :: vxz_d1 = vyz_d1
        end subroutine MakeMagGradGridDH

        subroutine MakeMagGridPoint(vec,cilm,lmax,a,r,lat,lon,dealloc,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pymakemaggridpoint
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: a
            real(dp),intent(in) :: r
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            integer(int32),optional,intent(in) :: dealloc = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            real(dp),dimension(3),intent(out) :: vec
        end subroutine MakeMagGridPoint

        subroutine MakeGeoidGridDH(exitstatus,geoid,cilm,lmax,r0pot,GM,PotRef,omega,r,sampling,order,nlat,nlong,lmax_calc,a,f,extend,cilm_d0,cilm_d1,cilm_d2,geoid_d0,geoid_d1)
            threadsafe
            fortranname pymakegeoidgriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(geoid_d0,geoid_d1),intent(out) :: geoid
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: r0pot
            real(dp),intent(in) :: GM
            real(dp),intent(in) :: PotRef
            real(dp),optional,intent(in) :: omega = 0.0
            real(dp),optional,intent(in) :: r = r0pot
            integer(int32),optional,check(sampling==1 || sampling==2),intent(in) :: sampling = 2
            integer(int32),optional,intent(in) :: order = 2
            integer(int32),intent(hide) :: nlat
            integer(int32),intent(hide) :: nlong
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            real(dp),optional,intent(in) :: a = r
            real(dp),optional,intent(in) :: f = 0.0
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),intent(hide),depend(lmax,extend),check(lmax>=0) :: geoid_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),intent(hide),depend(sampling,lmax,extend) :: geoid_d1 = sampling*2*(lmax+1)+extend
        end subroutine MakeGeoidGridDH

        subroutine CilmPlusDH(exitstatus,cilm,gridin,lmax,nmax,mass,d,rho,sampling,n,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pycilmplusdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer(int32),optional,intent(in),depend(n) :: lmax = n/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(out) :: d
            real(dp),intent(in) :: rho
            integer(int32),optional,depend(gridin_d0,gridin_d1),intent(in) :: sampling = gridin_d1/gridin_d0
            integer(int32),optional,intent(in),depend(gridin_d0),intent(hide) :: n = gridin_d0
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d0 = shape(gridin,0)
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d1 = shape(gridin,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: cilm_d2 = lmax+1
        end subroutine CilmPlusDH

        subroutine CilmMinusDH(exitstatus,cilm,gridin,lmax,nmax,mass,d,rho,sampling,n,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pycilmminusdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer(int32),optional,intent(in),depend(n) :: lmax = n/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(out) :: d
            real(dp),intent(in) :: rho
            integer(int32),depend(gridin_d0,gridin_d1),intent(hide) :: sampling = gridin_d1/gridin_d0
            integer(int32),optional,intent(in),depend(gridin_d0) :: n = gridin_d0
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d0 = shape(gridin,0)
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d1 = shape(gridin,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: cilm_d2 = lmax+1
        end subroutine CilmMinusDH

        subroutine CilmPlusRhoHDH(exitstatus,cilm,gridin,lmax,nmax,mass,d,rho,sampling,n,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2,rho_d0,rho_d1)
            threadsafe
            fortranname pycilmplusrhohdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer(int32),optional,intent(in),depend(n) :: lmax = n/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(out) :: d
            real(dp),dimension(rho_d0,rho_d1),intent(in) :: rho
            integer(int32),optional,depend(gridin_d0,gridin_d1) :: sampling = gridin_d1/gridin_d0
            integer(int32),optional,intent(in),depend(gridin_d0):: n = gridin_d0
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d0 = shape(gridin,0)
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d1 = shape(gridin,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: cilm_d2 = lmax+1
            integer(int32),optional,intent(in),depend(rho) :: rho_d0 = shape(rho,0)
            integer(int32),optional,intent(in),depend(rho) :: rho_d1 = shape(rho,1)
        end subroutine CilmPlusRhoHDH

        subroutine CilmMinusRhoHDH(exitstatus,cilm,gridin,lmax,nmax,mass,d,rho,sampling,n,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2,rho_d0,rho_d1)
            threadsafe
            fortranname pycilmminusrhohdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer(int32),optional,intent(in),depend(n) :: lmax = n/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(out) :: d
            real(dp),dimension(rho_d0,rho_d1),intent(in) :: rho
            integer(int32),optional,depend(gridin_d0,gridin_d1) :: sampling = gridin_d1/gridin_d0
            integer(int32),optional,intent(in),depend(gridin_d0) :: n = gridin_d0
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d0 = shape(gridin,0)
            integer(int32),optional,intent(in),depend(gridin) :: gridin_d1 = shape(gridin,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax),check(lmax>=0) :: cilm_d1 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: cilm_d2 = lmax+1
            integer(int32),optional,intent(in),depend(rho) :: rho_d0 = shape(rho,0)
            integer(int32),optional,intent(in),depend(rho) :: rho_d1 = shape(rho,1)
        end subroutine CilmMinusRhoHDH

        subroutine BAtoHilmDH(exitstatus,cilm,ba,griddh,lmax,nmax,mass,r0,rho,sampling,filter_type,filter_deg,lmax_calc,ba_d0,ba_d1,ba_d2,griddh_d0,griddh_d1,cilm_d0,cilm_d1,cilm_d2)
            threadsafe
            fortranname pybatohilmdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(ba_d0,ba_d1,ba_d2),intent(in) :: ba
            real(dp),dimension(griddh_d0,griddh_d1),intent(in) :: griddh
            integer(int32),optional,intent(in),depend(griddh_d0) :: lmax = griddh_d0/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(in) :: r0
            real(dp),intent(in) :: rho
            integer(int32),optional,intent(in),depend(griddh_d0,griddh_d1) :: sampling = griddh_d1/griddh_d0
            integer(int32),optional,intent(in) :: filter_type = 0
            integer(int32),optional,intent(in) :: filter_deg = 0
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in),depend(ba) :: ba_d0 = shape(ba,0)
            integer(int32),optional,intent(in),depend(ba) :: ba_d1 = shape(ba,1)
            integer(int32),optional,intent(in),depend(ba) :: ba_d2 = shape(ba,2)
            integer(int32),optional,intent(in),depend(griddh) :: griddh_d0 = shape(griddh,0)
            integer(int32),optional,intent(in),depend(griddh) :: griddh_d1 = shape(griddh,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax_calc),check(lmax_calc>=0) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax_calc) :: cilm_d2 = lmax_calc+1
        end subroutine BAtoHilmDH

        subroutine BAtoHilmRhoHDH(exitstatus,cilm,ba,griddh,rho,lmax,nmax,mass,r0,sampling,filter_type,filter_deg,lmax_calc,ba_d0,ba_d1,ba_d2,griddh_d0,griddh_d1,cilm_d0,cilm_d1,cilm_d2,rho_d0,rho_d1)
            threadsafe
            fortranname pybatohilmrhohdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(out) :: cilm
            real(dp),dimension(ba_d0,ba_d1,ba_d2),intent(in) :: ba
            real(dp),dimension(griddh_d0,griddh_d1),intent(in) :: griddh
            real(dp),dimension(rho_d0,rho_d1),intent(in) :: rho
            integer(int32),optional,intent(in),depend(griddh_d0) :: lmax = griddh_d0/2-1
            integer(int32),intent(in) :: nmax
            real(dp),intent(in) :: mass
            real(dp),intent(in) :: r0
            integer(int32),optional,intent(in),depend(griddh_d0,griddh_d1) :: sampling = griddh_d1/griddh_d0
            integer(int32),optional,intent(in) :: filter_type = 0
            integer(int32),optional,intent(in) :: filter_deg = 0
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in),depend(ba) :: ba_d0 = shape(ba,0)
            integer(int32),optional,intent(in),depend(ba) :: ba_d1 = shape(ba,1)
            integer(int32),optional,intent(in),depend(ba) :: ba_d2 = shape(ba,2)
            integer(int32),optional,intent(in),depend(griddh) :: griddh_d0 = shape(griddh,0)
            integer(int32),optional,intent(in),depend(griddh) :: griddh_d1 = shape(griddh,1)
            integer(int32),optional,intent(in),intent(hide) :: cilm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax_calc),check(lmax_calc>=0) :: cilm_d1 = lmax_calc+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax_calc) :: cilm_d2 = lmax_calc+1
            integer(int32),optional,intent(in),depend(rho) :: rho_d0 = shape(rho,0)
            integer(int32),optional,intent(in),depend(rho) :: rho_d1 = shape(rho,1)
        end subroutine BAtoHilmRhoHDH

        function DownContFilterMA(l,half,r,d)
            threadsafe
            fortranname pydowncontfilterma
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(in) :: l
            integer(int32),intent(in) :: half
            real(dp),intent(in) :: r
            real(dp),intent(in) :: d
            real(dp) :: DownContFilterMA
        end function DownContFilterMA

        function DownContFilterMC(l,half,r,d)
            threadsafe
            fortranname pydowncontfiltermc
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(in) :: l
            integer(int32),intent(in) :: half
            real(dp),intent(in) :: r
            real(dp),intent(in) :: d
            real(dp) :: DownContFilterMC
        end function DownContFilterMC

        function NormalGravity(geocentric_lat,gm,omega,a,b)
            threadsafe
            fortranname pynormalgravity
            integer, parameter :: dp = selected_real_kind(p=15)
            real(dp),intent(in) :: geocentric_lat
            real(dp),intent(in) :: gm
            real(dp),intent(in) :: omega
            real(dp),intent(in) :: a
            real(dp),intent(in) :: b
            real(dp) :: NormalGravity
        end function NormalGravity

        subroutine MakeMagGridDH(exitstatus,cilm,lmax,r0,a,f,rad,theta,phi,total,pot,n,sampling,lmax_calc,extend,total_d0,total_d1,cilm_d0,cilm_d1,cilm_d2,rad_d0,rad_d1,theta_d0,theta_d1,phi_d0,phi_d1,pot_d0,pot_d1)
            threadsafe
            fortranname pymakemaggriddh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),intent(in) :: r0
            real(dp),optional,intent(in),depend(r0) :: a = r0
            real(dp),optional,intent(in) :: f = 0.0
            real(dp),dimension(rad_d0,rad_d1),intent(out) :: rad
            real(dp),dimension(theta_d0,theta_d1),intent(out) :: theta
            real(dp),dimension(phi_d0,phi_d1),intent(out) :: phi
            real(dp),dimension(total_d0,total_d1),intent(out) :: total
            real(dp),dimension(pot_d0,pot_d1),intent(out) :: pot
            integer(int32),intent(hide) :: n
            integer(int32),optional,intent(in) :: sampling = 2
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(lmax,extend),intent(hide),check(lmax>=0) :: total_d0 = 2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(sampling,lmax,extend) :: total_d1 = sampling*2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),optional,intent(in),intent(hide),depend(total_d0) :: rad_d0 = total_d0
            integer(int32),optional,intent(in),intent(hide),depend(total_d1) :: rad_d1 = total_d1
            integer(int32),optional,intent(in),intent(hide),depend(total_d0) :: theta_d0 = total_d0
            integer(int32),optional,intent(in),intent(hide),depend(total_d1) :: theta_d1 = total_d1
            integer(int32),optional,intent(in),intent(hide),depend(total_d0) :: phi_d0 = total_d0
            integer(int32),optional,intent(in),intent(hide),depend(total_d1) :: phi_d1 = total_d1
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: pot_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: pot_d1 = phi_d1
        end subroutine MakeMagGridDH

        subroutine MakeCircleCoord(exitstatus,coord,lat,lon,theta0,cinterval,cnum,coord_d0,coord_d1)
            threadsafe
            fortranname pymakecirclecoord
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(coord_d0,coord_d1),intent(out) :: coord
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            real(dp),intent(in) :: theta0
            real(dp),optional,intent(in) :: cinterval = 1.0
            integer(int32),intent(hide) :: cnum
            integer(int32),intent(in),intent(hide),depend(cinterval),check(cinterval>=0) :: coord_d0 = (int)(360.0/cinterval)
            integer(int32),intent(in),intent(hide) :: coord_d1 = 2
        end subroutine MakeCircleCoord

        subroutine MakeEllipseCoord(exitstatus,coord,lat,lon,dec,A_theta,B_theta,cinterval,cnum,coord_d0,coord_d1)
            threadsafe
            fortranname pymakeellipsecoord
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(coord_d0,coord_d1),intent(out) :: coord
            real(dp),intent(in) :: lat
            real(dp),intent(in) :: lon
            real(dp),intent(in) :: dec
            real(dp),intent(in) :: A_theta
            real(dp),intent(in) :: B_theta
            real(dp),optional,intent(in) :: cinterval = 1.0
            integer(int32),intent(hide) :: cnum
            integer(int32),intent(in),intent(hide),depend(cinterval),check(cinterval>=0) :: coord_d0 = (int)(360.0/cinterval)
            integer(int32),intent(in),intent(hide) :: coord_d1 = 2
        end subroutine MakeEllipseCoord

        subroutine Wigner3j(exitstatus,w3j,jmin,jmax,j2,j3,m1,m2,m3,w3j_d0)
            threadsafe
            fortranname pywigner3j
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(w3j_d0),intent(out) :: w3j
            integer(int32),intent(out) :: jmin
            integer(int32),intent(out) :: jmax
            integer(int32),intent(in) :: j2
            integer(int32),intent(in) :: j3
            integer(int32),intent(in) :: m1
            integer(int32),intent(in) :: m2
            integer(int32),intent(in) :: m3
            integer(int32),intent(in),intent(hide) :: w3j_d0 = j2+j3+1
        end subroutine Wigner3j

        subroutine DHaj(exitstatus,n,aj,extend,aj_d0)
            threadsafe
            fortranname pydhaj
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(aj_d0),intent(out) :: aj
            integer(int32),intent(in) :: n
            integer(int32),optional,intent(in) :: extend = 0
            integer(int32),optional,intent(in),depend(n,extend),intent(hide) :: aj_d0 = n + extend
        end subroutine DHaj

        subroutine SHRotateTapers(exitstatus,tapersrot,tapers,taper_order,lmax,nrot,x,dj,tapersrot_d0,tapersrot_d1,tapers_d0,tapers_d1,taper_order_d0,dj_d0,dj_d1,dj_d2)
            threadsafe
            fortranname pyshrotatetapers
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(tapersrot_d0,tapersrot_d1),intent(out) :: tapersrot
            real(dp),dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer(int32),dimension(taper_order_d0),intent(in) :: taper_order
            integer(int32),optional,intent(in),intent(hide),depend(tapers) :: lmax = shape(tapers,0)-1
            integer(int32),intent(in) :: nrot
            real(dp),intent(in) :: x(3)
            real(dp),dimension(dj_d0,dj_d1,dj_d2),intent(in) ::dj
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: tapersrot_d0 = (lmax+1)*(lmax+1)
            integer(int32),optional,intent(in),intent(hide),depend(nrot) :: tapersrot_d1 = nrot
            integer(int32),optional,intent(in),intent(hide),depend(tapers) :: tapers_d0 = shape(tapers,0)
            integer(int32),optional,intent(in),intent(hide),depend(tapers) :: tapers_d1 = shape(tapers,1)
            integer(int32),optional,intent(in),intent(hide),depend(taper_order):: taper_order_d0 = len(taper_order)
            integer(int32),optional,intent(in),intent(hide),depend(dj) :: dj_d0 = shape(dj,0)
            integer(int32),optional,intent(in),intent(hide),depend(dj) :: dj_d1 = shape(dj,1)
            integer(int32),optional,intent(in),intent(hide),depend(dj) :: dj_d2 = shape(dj,2)
        end subroutine SHRotateTapers

        subroutine SlepianCoeffs(exitstatus,falpha,galpha,flm,lmax,nmax,falpha_d0,galpha_d0,galpha_d1,flm_d0,flm_d1,flm_d2)
            threadsafe
            fortranname pyslepiancoeffs
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(falpha_d0),intent(out) :: falpha
            real(dp),dimension(galpha_d0,galpha_d1),intent(in) :: galpha
            real(dp),dimension(flm_d0,flm_d1,flm_d2),intent(in) :: flm
            integer(int32),optional,intent(in),intent(hide),depend(galpha_d0) :: lmax = sqrt(galpha_d0)-1
            integer(int32),intent(in) :: nmax
            integer(int32),optional,intent(in),intent(hide),depend(nmax) :: falpha_d0 = nmax
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d0 = shape(galpha,0)
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d1 = shape(galpha,1)
            integer(int32),optional,intent(in),intent(hide),depend(flm) :: flm_d0 = shape(flm,0)
            integer(int32),optional,intent(in),intent(hide),depend(flm) :: flm_d1 = shape(flm,1)
            integer(int32),optional,intent(in),intent(hide),depend(flm) :: flm_d2 = shape(flm,2)
        end subroutine SlepianCoeffs

        subroutine SlepianCoeffsToSH(exitstatus,flm,falpha,galpha,lmax,nmax,flm_d0,flm_d1,flm_d2,falpha_d0,galpha_d0,galpha_d1)
            threadsafe
            fortranname pyslepiancoeffstosh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(flm_d0,flm_d1,flm_d2),intent(out) :: flm
            real(dp),dimension(galpha_d0,galpha_d1),intent(in) :: galpha
            real(dp),dimension(falpha_d0),intent(in) :: falpha
            integer(int32),optional,intent(in),intent(hide),depend(galpha_d0) :: lmax = sqrt(galpha_d0)-1
            integer(int32),intent(in) :: nmax
            integer(int32),optional,intent(in),intent(hide) :: flm_d0 = 2
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: flm_d1 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: flm_d2 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(falpha) :: falpha_d0 = len(falpha)
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d0 = shape(galpha,0)
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d1 = shape(galpha,1)
        end subroutine SlepianCoeffsToSH

        subroutine SHSCouplingMatrix(exitstatus,kij,galpha,lmax,nmax,kij_d0,kij_d1,galpha_d0,galpha_d1)
            threadsafe
            fortranname pyshscouplingmatrix
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(kij_d0,kij_d1),intent(out) :: kij
            real(dp),dimension(galpha_d0,galpha_d1),intent(in) :: galpha
            integer(int32),optional,intent(in),intent(hide),depend(galpha_d0) :: lmax = sqrt(galpha_d0)-1
            integer(int32),intent(in) :: nmax
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: kij_d0 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(kij_d0) :: kij_d1 = kij_d0
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d0 = shape(galpha,0)
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d1 = shape(galpha,1)
        end subroutine SHSCouplingMatrix

        subroutine SHSlepianVar(exitstatus,l,galpha,galpha_order,Sff,kmax,lmax,variance,galpha_order_d0,Sff_d0,galpha_d0,galpha_d1)
            threadsafe
            fortranname pyshslepianvar
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            integer(int32),intent(in) :: l
            real(dp),dimension(galpha_d0,galpha_d1),intent(in) :: galpha
            integer(int32),dimension(galpha_order_d0),intent(in) :: galpha_order
            real(dp),dimension(Sff_d0),intent(in) :: Sff
            integer(int32),optional,intent(in),depend(galpha_d1) :: kmax = galpha_d1
            integer(int32),optional,intent(in),depend(galpha_d0),intent(hide) :: lmax = galpha_d0-1
            real(dp),intent(out) :: variance
            integer(int32),optional,intent(in),depend(galpha_order),intent(hide) :: galpha_order_d0 = len(galpha_order)
            integer(int32),optional,intent(in),depend(Sff),intent(hide) :: Sff_d0 = len(Sff)
            integer(int32),optional,intent(in),depend(galpha),intent(hide) :: galpha_d0 = shape(galpha,0)
            integer(int32),optional,intent(in),depend(galpha),intent(hide) :: galpha_d1 = shape(galpha,1)
        end subroutine SHSlepianVar

        subroutine SHSCouplingMatrixCap(exitstatus,kij,galpha,galpha_order,lmax,nmax,kij_d0,kij_d1,galpha_d0,galpha_d1,galpha_order_d0)
            threadsafe
            fortranname pyshscouplingmatrixcap
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(kij_d0,kij_d1),intent(out) :: kij
            real(dp),dimension(galpha_d0,galpha_d1),intent(in) :: galpha
            integer(int32),dimension(galpha_order_d0),intent(in) :: galpha_order
            integer(int32),optional,intent(in),intent(hide),depend(galpha_d0) :: lmax = galpha_d0-1
            integer(int32),intent(in) :: nmax
            integer(int32),optional,intent(in),intent(hide),depend(lmax) :: kij_d0 = lmax+1
            integer(int32),optional,intent(in),intent(hide),depend(kij_d0) :: kij_d1 = kij_d0
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d0 = shape(galpha,0)
            integer(int32),optional,intent(in),intent(hide),depend(galpha) :: galpha_d1 = shape(galpha,1)
            integer(int32),optional,intent(in),depend(galpha_order),intent(hide) :: galpha_order_d0 = len(galpha_order)
        end subroutine SHSCouplingMatrixCap

        subroutine MakeGradientDH(exitstatus,cilm,lmax,theta,phi,n,sampling,lmax_calc,extend,radius,phi_d0,phi_d1,cilm_d0,cilm_d1,cilm_d2,theta_d0,theta_d1)
            threadsafe
            fortranname pymakegradientdh
            integer, parameter :: dp = selected_real_kind(p=15)
            integer, parameter :: int32 = selected_int_kind(9)
            integer(int32),intent(out) :: exitstatus
            real(dp),dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer(int32),optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real(dp),dimension(theta_d0,theta_d1),intent(out) :: theta
            real(dp),dimension(phi_d0,phi_d1),intent(out) :: phi
            integer(int32),intent(hide) :: n
            integer(int32),optional,intent(in) :: sampling = 2
            integer(int32),optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer(int32),optional,intent(in) :: extend = 0
            real(dp),optional,intent(in) :: radius = 1.0
            integer(int32),intent(in),intent(hide),depend(lmax,extend),check(lmax>=0) :: phi_d0 = 2*(lmax+1)+extend
            integer(int32),intent(in),intent(hide),depend(sampling,lmax,extend) :: phi_d1 = sampling*2*(lmax+1)+extend
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d0 = shape(cilm,0)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d1 = shape(cilm,1)
            integer(int32),optional,intent(in),depend(cilm),intent(hide) :: cilm_d2 = shape(cilm,2)
            integer(int32),intent(in),intent(hide),depend(phi_d0) :: theta_d0 = phi_d0
            integer(int32),intent(in),intent(hide),depend(phi_d1) :: theta_d1 = phi_d1
        end subroutine MakeGradientDH

    end interface

end python module _SHTOOLS
