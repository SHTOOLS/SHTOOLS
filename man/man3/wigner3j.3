.\" Automatically generated by Pandoc 3.8.2.1
.\"
.TH "wigner3j" "1" "2021\-02\-15" "Fortran 95" "SHTOOLS 4.14"
.SH Wigner3j
Compute the Wigner\-3j symbols for all allowable values of J.
.SH Usage
call Wigner3j (\f[CR]w3j\f[R], \f[CR]jmin\f[R], \f[CR]jmax\f[R],
\f[CR]j2\f[R], \f[CR]j3\f[R], \f[CR]m1\f[R], \f[CR]m2\f[R],
\f[CR]m3\f[R], \f[CR]exitstatus\f[R])
.SH Parameters
.TP
\f[CR]w3j\f[R] : output, real(dp), dimension (\f[CR]j2\f[R]+\f[CR]j3\f[R]+1)
An array of the Wigner\-3j symbols evaluated for all allowable values of
\f[CR]j\f[R].
The minimum and maximum values of \f[CR]j\f[R] are given by
\f[CR]jmin\f[R] and \f[CR]jmax\f[R].
.TP
\f[CR]jmin\f[R] : output, integer(int32)
The minimum value of \f[CR]j\f[R] in the array \f[CR]w3j\f[R].
This corresponds to the first element of \f[CR]w3j\f[R].
.TP
\f[CR]jmax\f[R] : output, integer(int32)
The maximum value of \f[CR]j\f[R] in the array \f[CR]w3j\f[R].
This corresponds to the last non\-zero element of \f[CR]w3j\f[R].
.TP
\f[CR]j2\f[R] : input, integer(int32)
A positive integer.
.TP
\f[CR]j3\f[R] : input, integer(int32)
A positive integer.
.TP
\f[CR]m1\f[R] : input, integer(int32)
An integer.
.TP
\f[CR]m2\f[R] : input, integer(int32)
An integer.
.TP
\f[CR]m3\f[R] : input, integer(int32)
An integer.
.TP
\f[CR]exitstatus\f[R] : output, optional, integer(int32)
If present, instead of executing a STOP when an error is encountered,
the variable exitstatus will be returned describing the error.
0 = No errors; 1 = Improper dimensions of input array; 2 = Improper
bounds for input variable; 3 = Error allocating memory; 4 = File IO
error.
# Description
.PP
\f[CR]Wigner3j\f[R] will calculate the Wigner 3J symbols
.PP
\f[CR]/ j  j2 j3 \(rs\f[R]
.PD 0
.P
.PD
\f[CR]\(rs m1 m2 m3 /\f[R]
.PP
for all allowable values of \f[CR]j\f[R].
The returned values in the array \f[CR]w3j\f[R] are calculated only for
the limits
.PP
\f[CR]jmin = max(|j2\-j3|, |m1|)\f[R] and
.PP
\f[CR]jmax = j2 + j3\f[R].
.PP
To be non\-zero, \f[CR]m1+m2+m3\f[R] must equal 0.
It is assumed that all \f[CR]j\f[R]s and \f[CR]m\f[R]s are integers.
Returned values have a relative error less than \(ti1.d\-8 when
\f[CR]j2\f[R] and \f[CR]j3\f[R] are less than about 100 (see below).
In practice, this routine is probably usable up to about 165.
.PP
The employed algorithm is based upon the stable non\-linear recurrence
relations of Luscombe and Luban (1998) for the \(lqnon classical\(rq
regions near \f[CR]jmin and jmax\f[R].
The direction of the iteration starts from low values of \f[CR]j\f[R] to
high values, but when \f[CR]abs(w3j(j+2)/w3j(j))\f[R] is less than one,
the iteration will restart from high to low values.
For the classical region, the standard three term recursion relationship
is used (e.g., Schulten and Gordon 1975).
As this three term recursion can lead to overflows, the values are
rescaled by a factor \(lqscalef\(rq whenever the absolute value of the
3j coefficient becomes greater than unity.
More efficient algorithms probably exist for specific cases (for
instance, when all Ms are zero).
.PP
The results of this routine have been verified against the same routine
run in quadruple precision.
For 1.e7 acceptable random values of \f[CR]j2\f[R], \f[CR]j3\f[R],
\f[CR]m2\f[R], and \f[CR]m3\f[R] between \-200 and 200, the relative
error was calculated only for those 3j coefficients that had an absolute
value greater than 1.d\-17 (values smaller than this are for all
practical purposed zero, and can be heavily affected by machine roundoff
errors or underflow).
853 combinations of parameters were found to have relative errors
greater than 1.d\-8.
Here I list the minimum value of \f[CR]max(j2,j3)\f[R] for different
ranges of error, as well as the number of times this error occurred:
.PP
\f[CR]max(j2,j3) = 103: 1.d\-7 < error <=1.d\-8 ; Number of occurrences = 483\f[R]
.PD 0
.P
.PD
\f[CR]max(j2,j3) = 116: 1.d\-6 < error <= 1.d\-7 ; Number of occurrences = 240\f[R]
.PD 0
.P
.PD
\f[CR]max(j2,j3) = 165: 1.d\-5 < error <= 1.d\-6 ; Number of occurrences = 93\f[R]
.PD 0
.P
.PD
\f[CR]max(j2,j3) = 167: 1.d\-4 < error <= 1.d\-5 ; Number of occurrences = 36\f[R]
.PP
Many times, the large relative errors occur when the 3j coefficient
changes sign and is very close to zero (i.e., adjacent values are about
1.e7 times greater in magnitude).
Thus, if one does not need to know highly accurate values of the 3j
coefficients when they are almost zero (i.e., \(ti1.e\-10) then this
routine is probably usable up to about 160.
.PP
These results have also been verified for parameter values less than 100
using a code based on the algorith of de Blanc (1987), which was
originally coded by Olav van Genabeek, and modified by M. Fang.
(This code was run in quadruple precision and only calculates one
coefficient for each call.)
Maximum relative errors between the two routines were less than 1.d\-8
for a large number of values (again, only 3j coefficients greater than
1.d\-17 were considered here).
.SH References
Luscombe, J. J., and M. Luban, Simplified recursive algorithm for Wigner
3j and 6j symbols, Phys.
Rev.\ E, 57, 7274\-7277, 1998.
.PP
Schulten, K., and R. G. Gordon, Exact recursive evaluation of
3j\-coefficients and 6j\-coefficients for quantum\-mechanical coupling
of angular momenta, J. Math.
Phys., 16, 1961\-1970, 1975.
