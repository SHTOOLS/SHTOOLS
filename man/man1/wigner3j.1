.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WIGNER3J 1"
.TH WIGNER3J 1 "2015-03-10" "SHTOOLS 3.0" "SHTOOLS 3.0"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Wigner3j"
.IX Header "Wigner3j"
.IP "Wigner3j \-" 11
.IX Item "Wigner3j -"
Compute the Wigner\-3j symbols for all allowable values of J.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.IP "\s-1SUBROUTINE\s0 Wigner3j (" 22
.IX Item "SUBROUTINE Wigner3j ("
W3J, \s-1JMIN, JMAX, J2, J3, M1, M2, M3 \s0)
.RS 4
.IP "REAL*8" 10
.IX Item "REAL*8"
W3J(J2+J3+1)
.IP "\s-1INTEGER\s0" 10
.IX Item "INTEGER"
\&\s-1JMIN, JMAX, J2, J3, M1, M2, M3\s0
.RE
.RS 4
.RE
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIWigner3j\fR  will calculate the Wigner 3J symbols
.PP
.Vb 2
\&        / J  J2 J3 \e
\&        \e M1 M2 M3 /
.Ve
.PP
for all allowable values of J. The returned values in the array W3J are calculated only for the limits
.Sp
.RS 10
\&\s-1JMIN\s0 = max(|J2\-J3|, M1|)  and
.Sp
\&\s-1JMAX\s0 = J2 + J3.
.RE
.PP
To be non-zero, M1 + M2 + M3 must equal 0. It is assumed that all Js and Ms are integers. Returned values have a relative error less than ~1.d\-8 when J2 and J3 are less than about 100 (see \s-1NOTES\s0 below). In practice, this routine is probably usable up to about 165.
.PP
The employed algorithm is based upon the stable non-linear recurrence relations of Luscombe and Luban (1998) for the \*(L"non classical\*(R" regions near \s-1JMIN\s0 and \s-1JMAX.\s0 The direction of the iteration starts from low values of J to high values, but when abs(W3J(J+2)/W3J(J)) is less than one, the iteration will restart from high to low values. For the classical region, the standard three term recursion relationship is used (e.g., Schulten and Gordon 1975). As this three term recursion can lead to overflows, the values are rescaled by a factor \*(L"scalef\*(R" whenever the absolute value of the 3j coefficient becomes greater than unity.  More efficient algorithms probably exist for specific cases (for instance, when all Ms are zero).
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
.IP "W3J" 10
.IX Item "W3J"
(output) REAL*8, \s-1DIMENSION \s0(J2+J3+1)
.Sp
An array of the Wigner\-3j symbols evaluated for all allowable values of J. The minimum and maximum values of J are given by \s-1JMIN\s0 and \s-1JMAX.\s0
.IP "\s-1JMIN\s0" 10
.IX Item "JMIN"
(output) \s-1INTEGER\s0
.Sp
The minimum value of J in the array W3J. This corresponds to the first element of W3J.
.IP "\s-1JMAX\s0" 10
.IX Item "JMAX"
(output) \s-1INTEGER\s0
.Sp
The maximum value of J in the array W3J. This corresponds to the last non-zero element of W3J.
.IP "J2" 10
.IX Item "J2"
(input) \s-1INTEGER\s0
.Sp
A positive integer.
.IP "J3" 10
.IX Item "J3"
(input) \s-1INTEGER\s0
.Sp
A positive integer.
.IP "M1" 10
.IX Item "M1"
(input) \s-1INTEGER\s0
.Sp
An integer.
.IP "M2" 10
.IX Item "M2"
(input) \s-1INTEGER\s0
.Sp
An integer.
.IP "M3" 10
.IX Item "M3"
(input) \s-1INTEGER\s0
.Sp
An integer.
.SH "NOTES"
.IX Header "NOTES"
The results of this routine have been verified against the same routine run in quadruple precision. For 1.e7 acceptable random values of J2, J3, M2, and M3 between \-200 and 200, the relative error was calculated only for those 3j coefficients that had an absolute value greater than 1.d\-17 (values smaller than this are for all practical purposed zero, and can be heavily affected by machine roundoff errors or underflow). 853 combinations of parameters were found to have relative errors greater than 1.d\-8. Here I list the minimum value of max(J2,J3) for different ranges of error, as well as the number of times this error occurred:
.Sp
.RS 5
(103) ; 1.d\-7 < error  <=1.d\-8 ; Number of occurrences = 483
.Sp
(116) ; 1.d\-6 < error <= 1.d\-7 ; Number of occurrences = 240
.Sp
(165) ; 1.d\-5 < error <= 1.d\-6 ; Number of occurrences = 93
.Sp
(167) 1.d\-4 < error <= 1.d\-5 ; Number of occurrences = 36
.RE
.PP
Many times (maybe always), the large relative errors occur when the 3j coefficient changes sign and is very close to zero (i.e., adjacent values are about 1.e7 times greater in magnitude). Thus, if one does not need to know highly accurate values of the 3j coefficients when they are almost zero (i.e., ~1.e\-10) then this routine is probably usable up to about 160.
.PP
These results have also been verified for parameter values less than 100 using a code based on the algorith of de Blanc (1987), which was originally coded by Olav van Genabeek, and modified by M. Fang. (This code was run in quadruple precision and only calculates one coefficient for each call.) Maximum relative errors between the two routines were less than 1.d\-8 for a large number of values (again, only 3j coefficients greater than 1.d\-17 were considered here).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://shtools.ipgp.fr/>
.SH "REFERENCES"
.IX Header "REFERENCES"
Luscombe, J. J., and M. Luban, Simplified recursive algorithm for Wigner 3j and 6j symbols, \fIPhys. Rev. E\fR, 57, 7274\-7277, 1998.
.PP
Schulten, K., and R. G. Gordon, Exact recursive evaluation of 3j\-coefficients
and 6j\-coefficients for quantum-mechanical coupling of angular momenta, \fIJ. Math. Phys.\fR, 16, 1961\-1970, 1975.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2012 by Mark Wieczorek <wieczor@ipgp.fr>.
.PP
This is free software; you can distribute and modify it under the terms of the revised \s-1BSD\s0 license.
